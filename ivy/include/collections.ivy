#lang ivy1.6

################################################################################
#
# Arrays
#
# Array types represent maps from an interval [0,end) of a type
# "domain" to a type "range".  An array type thing.t can be created
# like this:
#
#    instance thing : array(domain.t,range.t)
#
# The implementation of this type requires that domain.t be
# interpreted as 'int'.


module array(domain,range) = {

    type t

    # return an empty array

    action empty returns (a:t)

    # return an array with end=s and all values mapped to y
    action create(s:domain,y:range) returns (a:t)

    # mutate an array a so that x in [0,end) maps to y
    action set(a:t,x:domain,y:range) returns (a:t)

    # get the value y such that x in [0,end) maps to y in array a
    action get(a:t,x:domain) returns (y:range) 

    # get the value of end
    action size(a:t) returns (s:domain)
    
    # change the size of the array
    action resize(a:t,s:domain,v:range) returns (a:t)

    # add one element to the array
    action append(a:t,v:range) returns (a:t)

    ########################################
    # Representation
    #
    # Function "end" gives the end value of an array while value(a,x)
    # gives the value that x maps to in a.

    function end(A:t) : domain
    function value(A:t,X:domain) : range

    ########################################
    # Specification
    #
    # Notice that get and set have the precondition that x is in
    # [0,end).


    object spec = {
	property end(X) >= 0

	after empty {
	    assert end(a) = 0
	}
	before create {
	    assert 0 <= s
	}
	after create {
	    assert end(a) = s & value(a,X) = y
	}
        before set {
	    assert 0 <= x & x < end(a)
	}	       	 
	after set {
	    assert value(a,X) = y if X = x else value(old a,X)
	}
	before get {
	    assert 0 <= x & x < end(a)
	}
	after get {
	    assert value(a,x) = y
	}
	after size {
	    assert s = end(a)
	}
	after resize {
	    assert end(a) = s;
	    assert 0 <= X & X < end(old a) -> value(a,X) = value(old a,X);
	    assert end(old a) <= X & X < s -> value(a,X) = v
	}
	after append {
	    assert end(a) > end(old a) & ~(end(old a) < X & X < end(a));
	    assert 0 <= X & X < end(old a) -> value(a,X) = value(old a,X);
	    assert value(a,end(old a)) = v
	}
    }

    object impl = {

	interpret t -> <<< std::vector<`range`> >>>

	definition value(a:t,i:domain) = <<< (0 <= `i` && `i` < `a`.size()) ? `a`[`i`] : val >>>

	definition end(a:t) = <<< `a`.size() >>>

	implement create {
	    <<<
	        `a`.resize(`s`);
	        for (unsigned i = 0; i < `s`; i++)
	            `a`[i] = y;
	    >>>
	}

	implement empty {
	    <<<
	    >>>
	}

	implement set {
	    <<<
	        if (0 <= `x` && `x` < (`domain`)`a`.size()) 
	            `a`[`x`] = `y`;
	    >>>
	}

	implement get {
	    <<<
	        if (0 <= `x` && `x` < (`domain`)`a`.size()) 
	            `y` = `a`[`x`];
	    >>>
	}

	implement size {
	    <<<
	        `s` = (`domain`) `a`.size();
	    >>>
	}

	implement resize {
	    <<<
	        unsigned __old_size = `a`.size();
	        `a`.resize(`s`);
	        for (unsigned i = __old_size; i < (unsigned)`s`; i++)
	            `a`[i] = v;
            >>>
        }

	implement append {
	    <<<
	        `a`.push_back(`v`);
            >>>
        }

	<<< impl
	    std::ostream &operator <<(std::ostream &s, const `t` &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
	    }

	    template <>
	    `t` _arg<`t`>(std::vector<ivy_value> &args, unsigned idx, int bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        `t` a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<`range`>(arg.fields,i,0x7fffffff);
	        }
	        return a;
	    }

	    template <>
	    void __deser<`t`>(const std::vector<char> &inp, unsigned &pos, `t` &res) {
	        int sz;
	        __deser(inp,pos,sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
	            `range` v;
	            __deser(inp,pos,v);
	            res.push_back(v);
                }
	    }

	    template <>
	    void __ser<`t`>(std::vector<char> &res, const `t` &inp) {
	        int sz = inp.size();
	        __ser(res,sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
	            __ser(res,inp[i]);
                }
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, std::vector<`range`>& val) {
	        z3::expr z3end = g.apply("`end`",z3val);
	        return z3end  == g.int_to_z3(z3end.get_sort(),val.size());
            }

	    template <>
	    void  __from_solver<`t`>( gen &g, const  z3::expr &v,`t` &res){
	        `domain` __end;
	        __from_solver(g,g.apply("`end`",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("`value`",v,g.int_to_z3(g.sort("`domain`"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<`t`>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("`domain`"),__sz);
                z3::expr pred =  g.apply("`end`",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<`range`>(g,g.apply("`value`",v,g.int_to_z3(g.sort("`domain`"),__i)));
	    }
	    #endif

	>>>
    }

    trusted isolate iso = spec,impl
}

################################################################################
#
# Maps. 
#
# This module provides a relational model of a function from a type
# dom to a type rng. Initially, everything is mapped to the element zero.
# 
# The key invariant of a map is that it is a function, i.e., for every
# X there exists a Y such that map(X,Y). The module does not state
# this invariant, however, since the quantifier alternation could
# destroy stratification.  Instead it provides a "lemma" that allows
# the user to instantiate Y for particular values of X.
#
# Parameters:
#
#  dom        The domain type
#  rng        The range type
#  zero       The initial value for every domain element

module map(dom,rng,zero) = {

    relation map(X:dom,Y:rng)

    action set_(x:dom,y:rng)
    # get the value of x
    action get(x:dom) returns (y:rng)
    # prove there exists a value for x
    action lemma(x:dom)

    object spec = {
	init map(X,Y) <-> Y = zero

	implement set_(x:dom,y:rng) {
	    call lemma(x);
	    map(x,Y) := Y = y
	}
	implement get(x:dom) returns (y:rng) {
	    assume map(x,y)
	}
	implement lemma(x:dom) {
	    assume exists Y. map(x,Y)
	}
    }
    conjecture map(K,L) & map(K,M) -> L = M
}

################################################################################
#
# Partial functions
#
# This module represents a mutable partial function type dom to type
# rng. The state consists of relation map that stores the function as
# a set of tuples, and an auxiliary set pre that gives the pre-image.
#
################################################################################

module partial_function(dom,rng) = {

    relation map(X:dom,Y:rng)
    relation pre(X:dom) 

    # mutate the function so x maps to y
    action remap(x:dom,y:rng)

    # remove an element from the pre-image
    action remove(x:dom)

    # get the value of x, if any
    action get(x:dom) returns (y:rng)

    # true if x is in the pre-image
    action present(x:dom) returns (r:bool)
    
    # if x in pre, there exists a y such that map(x,y)
    action lemma(x:dom)

    object spec = {
	init ~map(X,Y)

	implement remap {
	    call lemma(x);
	    map(x,Y) := Y = y;
	    pre(x) := true
	}

	implement remove {
	    call lemma(x);
	    map(x,Y) := false;
	    pre(x) := false
	}

	after get {
	    assume pre(x) -> map(x,y)
	}

	after present {
	    assume r = pre(x)
	}

	implement lemma(x:dom) {
	    assume pre(x) -> exists Y. map(x,Y)
	}
    }

    conjecture map(K,L) & map(K,M) -> L = M

}

module set_wrapper(key) = {

    object s = {}

    <<< header
	#include <set>
    >>>

    <<< member
	std::set<`key`> `s`;
    >>>

    <<< init
        `s`.insert(0);
    >>>

    implement insert(x:key) {
	<<<
	    `s`.insert(`x`);
	>>>
    }

    implement erase(lo:key,hi:key) {
	<<<
            `s`.erase(`s`.lower_bound(`lo`),`s`.upper_bound(`hi`));
	>>>
    }

    implement get_glb(k:key) returns (res:key) {
	<<<
            `res` = *(--`s`.upper_bound(`k`));
	>>>
	
    }


}

################################################################################
#
# Ordered set representation
#
# This is intended to be implemented using the STL set template.
#
# Ordered sets assume the element type has a total non-strict order,
# with a least element 0.  They provide insertion of elements (in log
# time), deletion of ranges (in n log(n) time) and finding greatest
# lower bounds (log n).
# 
# For help with proofs, this module also provides an auxiliary map
# "succ" that gives the successor of every element in the set. The
# "successor" of the maximal element in the set is 0.

module ordered_set(key) = {

    action insert(nkey:key)
    action erase(lo:key,hi:key)
    action get_glb(k:key) returns (res:key)

    relation s(K:key)

    instantiate succ : map(key,key,0) # ghost

    object spec = {
	init s(K) <-> K = 0
	# insert one element
	before insert {
	    s(nkey) := true;

	    # following is ghost code to update the successor relation
	    local v:key {
		if some lub:key. ~(lub <= nkey) & s(lub) minimizing lub {
		    v := lub
		}
		else {
		    v := 0
		};
		call succ.set_(nkey,v)
	    };
	    if some glb:key. ~(nkey <= glb) & s(glb) maximizing glb {
		call succ.lemma(glb); # instantiate succ(glb)
		call succ.set_(glb,nkey)
	    }
	}

	# erase elements in a closed interval
	before erase {
	    s(K) := s(K) & ~(lo <= K & K <= hi)
	}

	# the the greatest element <= k
	after get_glb {
	    if some glb:key. glb <= k & s(glb) maximizing glb {
		call succ.lemma(glb); # instantiate succ(glb)
		assume res = glb
	    }
	}
    }

    # Useful invariants of the "succ" relation. The successor of K is
    # also in the set, and nothing between K and its successor is in
    # the set. Here, if L = 0 it means K is the maximim element, so we
    # have to treat this as a special case.

    conjecture s(K) & succ.map(K,L) & L ~= 0 -> ~(L <= K) & s(L)
    conjecture s(K) & succ.map(K,L) & ~(M <= K) & (L = 0 | ~(L <= M)) -> ~s(M)

    instance impl : set_wrapper(key)

}

module map_wrapper(key,value) = {

    object s = {}

    <<< header
	#include <map>
    >>>

    <<< member
	std::map<`key.t`,`value`> `s`;
    >>>

    <<< init
    >>>

    implement set(x:key.t,y:value) {
	<<<
	    `s`[`x`] = `y`;
	>>>
    }

    implement get(x:key.t,def:value) returns (y:value) {
	<<<
	    std::map<`key.t`,`value`>::iterator it = `s`.find(`x`);
	    if (it == `s`.end()) {
	        `y` = `def`;
	    } else {
	        `y` = it->second;
	    }
	>>>
    }

    implement erase(lo:key.iter.t,hi:key.iter.t) {
	<<<

            std::cout << "before: {";
	    for(std::map<`key.t`,`value`>::iterator __it = `s`.begin(), __en = `s`.end(); __it != __en; ++__it)
	        std::cout << __it->first << ":" << __it->second << ",";
            std::cout << "}" << std::endl;

	    if (!`lo`.is_end && (`hi`.is_end || `lo`.val < `hi`.val))
              `s`.erase(`lo`.is_end ? `s`.end() : `s`.lower_bound(`lo`.val),
 	                `hi`.is_end ? `s`.end() : `s`.lower_bound(`hi`.val));

            std::cout << "after: {";
	    for(std::map<`key.t`,`value`>::iterator __it = `s`.begin(), __en = `s`.end(); __it != __en; ++__it)
	        std::cout << __it->first << ":" << __it->second << ",";
            std::cout << "}" << std::endl;

	>>>
    }

    # implement begin(k:key.t) returns (res:key.iter.t) {
    # 	<<<
    # 	    std::map<`key.t`,`value`>::iterator __it = `s`.lower_bound(`k`);
    # 	    if (__it == `s`.end()) {
    # 	        `res`.is_end = true;
    # 	        `res`.val = 0;
    # 	    } else {
    #             `res`.is_end = false;
    # 	        `res`.val = __it->first;
    # 	    }
    # 	>>>
	
    # }

    implement lub(it:key.iter.t) returns (res:key.iter.t) {
	<<<
	    if (`it`.is_end) {
	     	`res`.is_end = true;
	        `res`.val = 0;
	    } else {
		std::map<`key.t`,`value`>::iterator __it = `s`.lower_bound(`it`.val);
		if (__it == `s`.end()) {
		    `res`.is_end = true;
		    `res`.val = 0;
		} else {
		    `res`.is_end = false;
		    `res`.val = __it->first;
		}
	    }
	>>>
	
    }

    implement glb(it:key.iter.t) returns (res:key.iter.t) {
	<<<
	    std::map<`key.t`,`value`>::iterator __it = `it`.is_end ? `s`.end() : `s`.upper_bound(`it`.val);
	    `res`.is_end = false;
            `res`.val = (--__it)->first;
	>>>
	
    }

    implement next(inp:key.iter.t) returns (res:key.iter.t) {
	<<<
	    std::map<`key.t`,`value`>::iterator __it = `s`.upper_bound(`inp`.val);
	    if (__it == `s`.end()) {
	        `res`.is_end = true;
	        `res`.val = 0;
	    } else {
                `res`.is_end = false;
	        `res`.val = __it->first;
	    }
	>>>
    }

    action show = {
	<<<
            std::cout << "{";
	    for(std::map<`key.t`,`value`>::iterator __it = `s`.begin(), __en = `s`.end(); __it != __en; ++__it)
	        std::cout << __it->first << ":" << __it->second << ",";
            std::cout << "}" << std::endl;
	>>>

    }
}

################################################################################
#
# Ordered map representation
#
# This is intended to be implemented using the STL map template.
#
# Ordered maps assume the key type has a total non-strict order, with
# a least element 0 and iteration.  They provide insertion of
# key/value pairs (in log time), deletion of ranges of keys (in n
# log(n) time) and iteration.
# 
# For help with proofs, this module also provides an auxiliary map
# "succ" that gives the successor of every element in the map. The
# "successor" of the maximal element in the map is 0.

module ordered_map(key,value) = {

    # set the value of key k
    action set(nkey:key.t,v:value)

    # is the key present in the map?
    action present(k:key.t) returns (ans:bool)

    # get the value of key k or zero
    action get(k:key.t,def:value) returns (v:value)

    # remove all leys in range [lo,hi]
    action erase(lo:key.iter.t,hi:key.iter.t)

    # get least iterator >= it
    action lub(it:key.iter.t) returns (res:key.iter.t)

    # get least iterator >= it
    action glb(it:key.iter.t) returns (res:key.iter.t)

    # iterator least key > iter or end
    action next(it:key.iter.t) returns (res:key.iter.t)

    relation contains(K:key.t)
    relation maps(K:key.t,V:value)

    function gap(k:key.iter.t,m:key.iter.t) =
              forall L. ~(key.iter.ahead(L,k) & key.iter.done(L,m) & contains(L))

    object spec = {

	init ~contains(K) & ~maps(K,V)

	property gap(W,X) & gap(Y,Z) & Y < X -> gap(W,Z)
	property gap(W,X) & W <= Y & Z <= X -> gap(Y,Z)
	property gap(K,M) -> ~(key.iter.ahead(L,K) & key.iter.done(L,M) & contains(L))

	# insert one element
	before set {
	    contains(nkey) := true;
	    maps(nkey,X) := X = v
	}


	after set {
	    local it:key.iter.t {
		it := key.iter.create(nkey);
		assert gap(X,Y) <-> old gap(X,Y) & ~(X < it & it < Y)
	    }
	}

	after get {
	    assert maps(k,v) & contains(k) | ~contains(k) & v = def
	}

	# erase elements in a closed interval
	before erase {
	    contains(K) := contains(K) & ~key.iter.between(lo,K,hi);
	    maps(K,V) := maps(K,V) & ~key.iter.between(lo,K,hi)
	}

	after erase {
	    assert gap(X,Y) <-> (old gap(X,Y)
	                         | old gap(X,lo) & old gap(hi,Y)
                                   & (Y < hi | key.iter.is_end(hi) | ~contains(key.iter.val(hi))))
	}

	after lub {
	    assert it <= res;
	    assert key.iter.between(it,X,res) -> ~contains(X);
	    assert key.iter.is_end(res) | (contains(key.iter.val(res))
	                                   & exists Y. maps(key.iter.val(res),Y))
#		assert succ(K,key.iter.val(res)) -> done(K,it)
	}

	before glb {
	    assert exists K. (~key.iter.ahead(K,it) & contains(K))
	}

	after glb {
	    assert res <= it & contains(key.iter.val(res));
	    assert exists U. (gap(res,U) & key.iter.between(res,key.iter.val(it),U))
	}

	before next {
	    assert it < key.iter.end
	}

	after next {
	    assert it < res & gap(it,res);
	    assert key.iter.is_end(res) | contains(key.iter.val(res))
	}

    }


    # Useful invariants of the "succ" relation. The successor of K is
    # also in the map, and nothing between K and its successor is in
    # the map. Here, if L = 0 it means K is the maximim element, so we
    # have to treat this as a special case.

#    conjecture contains(K) & succ.map(K,L) & L ~= 0 -> ~(L <= K) & contains(L)
#    conjecture contains(K) & succ.map(K,L) & ~(M <= K) & (L = 0 | ~(L <= M)) -> ~contains(M)

    # Mapping relation R is injective

    conjecture maps(X,Y) & maps(X,Z) -> Y = Z

    # Maps implies contains

    conjecture maps(X,Y) -> contains(X)

    instance impl : map_wrapper(key,value)

    trusted isolate iso = impl,spec

}


module ordered_map_impl(key,value) = {

    # set the value of key k
    action set(nkey:key.t,v:value)

    # is the key present in the map?
    action present(k:key.t) returns (ans:bool)

    # get the value of key k or zero
    action get(k:key.t,def:value) returns (v:value)

    # remove all leys in range [lo,hi]
    action erase(lo:key.iter.t,hi:key.iter.t)

    # get least iterator >= it
    action lub(it:key.iter.t) returns (res:key.iter.t)

    # get least iterator >= it
    action glb(it:key.iter.t) returns (res:key.iter.t)

    # iterator least key > iter or end
    action next(it:key.iter.t) returns (res:key.iter.t)

    instantiate map_wrapper(key,value)
}
