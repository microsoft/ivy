#lang ivy1.6

################################################################################
# A liveness proof of the ticket protocol according to the "modern"
# version of our methodology:
# * all existentially quantified variables come from action parameters
# * d is updated automatically by inserting all action parameters
# * change from paper: there are constant symbols in the vocabulary -
#   and they are handled both when updating d and when comparing states
################################################################################


################################################################################
# Module for axiomatizing a total order
#
################################################################################

module total_order(r) = {
    axiom r(X,X)                        # Reflexivity
    axiom r(X, Y) & r(Y, Z) -> r(X, Z)  # Transitivity
    axiom r(X, Y) & r(Y, X) -> X = Y    # Anti-symmetry
    axiom r(X, Y) | r(Y, X)             # Totality
}

################################################################################
#
# Types, relations and functions describing the state
#
################################################################################

object ticket_protocol = {

    ################################################################################
    #
    # The protocol itself, together with encoding the fairness
    # constraints and the negation of the liveness property
    #
    # property:      forall T:thread. G. pc2(T) -> F. pc3(T)
    # fairness:      forall T:thread. G. F. last_scheduled(T)
    # ~property:     exists T:thread. F. (pc2(T) & G. ~pc3(T))
    # Sk(~property): F. (pc2(t0) & G. ~pc3(t0))
    #
    ################################################################################

    type thread
    type ticket

    relation le(X:ticket, Y:ticket)
    instantiate total_order(le)
    individual zero:ticket
    axiom forall X. le(zero, X)

    relation pc1(T:thread)
    relation pc2(T:thread)
    relation pc3(T:thread)

    individual service:ticket
    individual next_ticket:ticket
    relation m(T:thread, K:ticket)  # use relation and not a function to be in EPR

    init pc1(T)
    init ~pc2(T)
    init ~pc3(T)
    init service = zero
    init next_ticket = zero
    init m(T,K) <-> K = zero

    relation request_flag

    # temporal specification
    temporal property [mutualexclusion] globally forall T1,T2. pc3(T1) & pc3(T2) -> T1 = T2
    #temporal property [nonstravation]   forall T:thread. globally  pc2(T) -> eventually pc3(T)
    # proof of nonstravation by l2s {
    temporal property ($l2s_w. request_flag) <-> ~request_flag
    #     conjecture l2s_frozen -> request_flag
    #     conjecture l2s_saved -> request_flag
    # }
    temporal axiom [fairness] forall T:thread. globally eventually pc1(T)
    #axiom [fairness] forall T:thread. globally eventually pc1(T)
    # temporal axiom [fairness] forall T:thread. globally eventually (
    #     (exists K1,K2. after step12(T,K1,K2)) |
    #     (exists K1. after step12(T,K1)) |
    #     (exists K1. after step12(T,K1)) |
    #     (exists K1,K2. after step12(T,K1,K2))
    # )
    # # naming for use in the inductive invariant
    # let t0 = nonstravation.T
    # let request_flag = pc2(t0) & globally ~pc3(t0)
    # let last_scheduled(T) = (
    #     (exists K1,K2. after step12(T,K1,K2)) |
    #     (exists K1. after step12(T,K1)) |
    #     (exists K1. after step12(T,K1)) |
    #     (exists K1,K2. after step12(T,K1,K2))
    # )
    # temporal property (forall T:thread. G. F. last_scheduled(T)) -> (forall T:thread. G. pc2(T) -> F. pc3(T))
    # fair action step12
    # fair action step22
    # fair action step23
    # fair action step31

    # Axioms we may need (not for ticket, in general):
    # (forall x. phi) -> (exists x. phi)
    # (exists x. eventually phi) -> (eventually exists x. phi)
    #
    # these may be needed when x isn't in d, and we know forall
    # x. eventually phi, and want to wait until (exists x. phi).


    ################################################################################
    #
    # Protocol actions
    #
    ################################################################################

    action succ(x:ticket) returns (y:ticket) = {
        assume ~le(y,x) & forall Z:ticket. ~le(Z,x) -> le(y,Z)
    }

    action step12(t:thread,k1:ticket, k2:ticket) = {
        assume pc1(t);
        assume k1 = next_ticket;
        assume k2 = succ(k1);
        m(t,K) := K = k1;
        next_ticket := k2;
        pc1(t) := false;
        pc2(t) := true;
    }

    action step22(t:thread, k1:ticket) = {
        assume pc2(t);
        assume m(t,k1);
        assume ~le(k1,service)
        # stay in pc2
    }

    action step23(t:thread, k1:ticket) = {
        assume pc2(t);
        assume m(t,k1);
        assume le(k1,service);
        pc2(t) := false;
        pc3(t) := true;
    }

    action step31(t:thread, k1:ticket, k2:ticket) = {
        assume pc3(t);
        assume k1 = service;
        assume k2 = succ(k1);
        service := k2;
        pc3(t) := false;
        pc1(t) := true
    }

    export step12
    export step22
    export step23
    export step31

    ################################################################################
    #
    # Conjectures for proving safety (also helps for liveness)
    #
    ################################################################################

    # basic
    conjecture pc1(T) | pc2(T) | pc3(T)
    conjecture ~pc1(T) | ~pc2(T)
    conjecture ~pc1(T) | ~pc3(T)
    conjecture ~pc2(T) | ~pc3(T)
    conjecture m(T,K1) & m(T,K2) -> K1 = K2

    # safety property
    conjecture pc3(T1) & pc3(T2) -> T1 = T2

    # inductive invariant for proving safety
    conjecture next_ticket = zero -> m(T,zero)
    conjecture next_ticket ~= zero & m(T,M) -> ~le(next_ticket,M)
    conjecture (pc2(T) | pc3(T)) -> next_ticket ~= zero
    conjecture m(T1,M) & m(T2,M) & M ~= zero -> T1 = T2
    conjecture pc2(T) & m(T,M) -> le(service,M)
    conjecture pc3(T) -> m(T,service)
    conjecture le(service,next_ticket)
    conjecture ~(~pc1(T1) & ~pc1(T2) & m(T1,zero) & m(T2,zero) & T1 ~= T2)

    ################################################################################
    #
    # The liveness to safety construction introduces the following symbols:
    #
    # relation   nonstravation.l2s.waiting
    # relation   nonstravation.l2s.frozen
    # relation   nonstravation.l2s.saved
    #
    # relation   nonstravation.l2s.d_thread(T:thread)
    # relation   nonstravation.l2s.d_ticket(K:ticket)
    #
    # relation   nonstravation.l2s.a_thread(T:thread)
    # relation   nonstravation.l2s.a_ticket(K:ticket)
    #
    # relation   nonstravation.l2s.w[phi] for phi in FO-LTL(original vocabulary)
    # relation   nonstravation.l2s.wa[A] for A in fair-actions = {step12(T,K1,K2),
    #                                                             step22(T,K1),
    #                                                             step23(T,K1),
    #                                                             step31(T,K1,K2)}
    #
    # relation   nonstravation.l2s.s.pc1(T:thread)
    # relation   nonstravation.l2s.s.pc2(T:thread)
    # relation   nonstravation.l2s.s.pc3(T:thread)
    # individual nonstravation.l2s.s.service : ticket
    # individual nonstravation.l2s.s.next_ticket : ticket
    # relation   nonstravation.l2s.s.m(T:thread, K:ticket)
    # relation   nonstravation.l2s.s.[phi] for phi in FO-LTL(original vocabulary)
    #
    ################################################################################


    ################################################################################
    #
    # Conjectures for proving liveness
    #
    ################################################################################


    # all safety conjectures for saved state are autumatically added
    # conjecture X.l2s.saved -> phi(X.l2s.s) for phi in conjectures over original vocabulary

    # # basic
    # conjecture nonstravation.l2s.w[request_flag] <-> ~request_flag
    # conjecture nonstravation.l2s.frozen -> request_flag
    # conjecture nonstravation.l2s.saved -> request_flag
    # conjecture request_flag -> pc2(t0)
    # conjecture nonstravation.l2s.saved -> nonstravation.l2s.s_m(t0,K) <-> m(t0,K)
    # conjecture nonstravation.l2s.saved -> le(nonstravation.l2s.s_service, service)

    # # more properties of reachable protocol states
    # conjecture pc1(T) & m(T,M) & M ~= zero -> ~le(service, M)
    # conjecture forall K:ticket. ~le(next_ticket, K) & le(service, K) ->
    #     exists T:thread. m(T,K) & ~pc1(T)
    #  conjecture exists M. m(t0, M)
    # # their saved counterpars are automatically added

    # # conjecture that nonstravation.l2s.d is large enough
    # conjecture nonstravation.l2s.d_thread(t0)
    # conjecture ~pc1(T) -> nonstravation.l2s.d_thread(T)
    # conjecture le(K,next_ticket) -> nonstravation.l2s.d_ticket(K)
    # # conjecture that nonstravation.l2s.a is large enough
    # conjecture ~nonstravation.l2s.waiting -> nonstravation.l2s.a_thread(t0)
    # conjecture ~nonstravation.l2s.waiting & m(T,K) & m(t0,K0) & ~le(K0,K) & ~pc1(T) -> nonstravation.l2s.a_thread(T)
    # conjecture ~nonstravation.l2s.waiting & m(t0,K0) & le(K,K0) -> nonstravation.l2s.a_ticket(K)

    # # thread that have not been scheduled have not changed
    # # conjecture l2s.saved & l2s.w_last_scheduled(T) -> (l2s.s_pc1(T) <-> pc1(T))
    # # conjecture l2s.saved & l2s.w_last_scheduled(T) -> (l2s.s_pc2(T) <-> pc2(T))
    # # conjecture l2s.saved & l2s.w_last_scheduled(T) -> (l2s.s_pc3(T) <-> pc3(T))
    # # conjecture l2s.saved & l2s.w_last_scheduled(T) -> (l2s.s_m(T,K) <-> m(T,K))
    # # this now will be written as:
    # conjecture (nonstravation.l2s.saved &
    #             nonstravation.l2s.s.pc1(T) &
    #             nonstravation.l2s.wa[step12(T,K1,K2)] problem with K1,K2 not being in d_...
    # # for now, try with last_scheduled
    # conjecture nonstravation.l2s.saved & nonstravation.l2s.w[last_scheduled](T) -> (
    #     (nonstravation.l2s.s_pc1(T) <-> pc1(T)) &
    #     (nonstravation.l2s.s_pc2(T) <-> pc2(T)) &
    #     (nonstravation.l2s.s_pc3(T) <-> pc3(T)) &
    #     (nonstravation.l2s.s_m(T,K) <-> m(T,K))
    # )

    # # the thread that must advance - the thread that had the service as its local ticket at the save point
    # conjecture (
    #     nonstravation.l2s.saved &
    #     nonstravation.l2s.s_m(T,nonstravation.l2s.s_service) &
    #     ~nonstravation.l2s.w[last_scheduled](T) &
    #     nonstravation.l2s.s_pc2(T) &
    #     m(T,K) &
    #     m(t0,K0)
    # ) -> (
    #     (pc1(T) & K = nonstravation.l2s.s_service) |
    #     (pc2(T) & ~le(K,K0)) |
    #     (pc3(T) & K = nonstravation.l2s.s_service)
    # )
    # conjecture (
    #     nonstravation.l2s.saved &
    #     nonstravation.l2s.s_m(T,nonstravation.l2s.s_service) &
    #     ~nonstravation.l2s.w[last_scheduled](T) &
    #     nonstravation.l2s.s_pc3(T) &
    #     m(T,K) &
    #     m(t0,K0)
    # ) -> (
    #     (pc1(T) & K = nonstravation.l2s.s_service & ~le(service, nonstravation.l2s.s_service)) |
    #     (pc2(T) & ~le(K,K0))
    # )

}
